var documenterSearchIndex = {"docs":
[{"location":"lineages/#Navigating-lineages","page":"Navigating lineages","title":"Navigating lineages","text":"","category":"section"},{"location":"lineages/#Core-functions","page":"Navigating lineages","title":"Core functions","text":"","category":"section"},{"location":"lineages/","page":"Navigating lineages","title":"Navigating lineages","text":"lineage\nchildren\ndescendants\nparent\nrank\ntaxonomicdistance!","category":"page"},{"location":"lineages/#NCBITaxonomy.lineage","page":"Navigating lineages","title":"NCBITaxonomy.lineage","text":"lineage(tax::NCBITaxon; stop_at::NCBITaxon=ncbi\"root\")\n\nReturns an array of NCBITaxon going up to the root of the taxonomy, or to the optionally specified stop_at taxonomic node.\n\n\n\n\n\n","category":"function"},{"location":"lineages/#NCBITaxonomy.children","page":"Navigating lineages","title":"NCBITaxonomy.children","text":"children(t::NCBITaxon)\n\nReturns the node immediately below the taxon given as argument, or nothing if the taxon is terminal.\n\n\n\n\n\n","category":"function"},{"location":"lineages/#NCBITaxonomy.descendants","page":"Navigating lineages","title":"NCBITaxonomy.descendants","text":"descendants(t::NCBITaxon)\n\nRecurisvely calls children until all terminal nodes under the taxon are reached. Depending on the taxonomic level, and number of taxa under the taxon considered, this can be a long function to run.\n\n\n\n\n\n","category":"function"},{"location":"lineages/#Base.parent","page":"Navigating lineages","title":"Base.parent","text":"parent(taxon::NCBITaxon)\n\nReturns the taxon from which the argument is descended.\n\n\n\n\n\n","category":"function"},{"location":"lineages/#NCBITaxonomy.rank","page":"Navigating lineages","title":"NCBITaxonomy.rank","text":"rank(taxon::NCBITaxon)\n\nReturns the rank of a taxon.\n\n\n\n\n\n","category":"function"},{"location":"lineages/#NCBITaxonomy.taxonomicdistance!","page":"Navigating lineages","title":"NCBITaxonomy.taxonomicdistance!","text":"This function fills a pre-allocated square matrix D with the taxonomic distance between taxa in a vector tax. The keywords areguments are d (the distance as a function to closest matching level), strict (a boolean to decide whether the distance of a taxon with itself should be read from the distance dictionary, or set to 0), and other keywords passed to the lineage function.\n\nBecause the distances are symetrical, there are only (n(n-1))/2 measurements to do.\n\nBy default, this function uses the distances from Shimatani (2001):\n\nequal rank distance\nspecies 0\ngenus 1\nfamily 2\nsubclass 3\n:fallback 4\n\nShimatani, K. 2001. On the measurement of species diversity incorporating species differences. Oikos 93:135–147. \n\n\n\n\n\n","category":"function"},{"location":"lineages/#Examples","page":"Navigating lineages","title":"Examples","text":"","category":"section"},{"location":"lineages/","page":"Navigating lineages","title":"Navigating lineages","text":"The children function will return a list of NCBITaxon that are immediately descending from the one given as argument. For example, the genus Lamellodiscus contains:","category":"page"},{"location":"lineages/","page":"Navigating lineages","title":"Navigating lineages","text":"using NCBITaxonomy\n\nncbi\"Lamellodiscus\" |> children","category":"page"},{"location":"lineages/","page":"Navigating lineages","title":"Navigating lineages","text":"Note that the parent function does the opposite of children:","category":"page"},{"location":"lineages/","page":"Navigating lineages","title":"Navigating lineages","text":"ncbi\"Lamellodiscus kechemirae\" |> parent","category":"page"},{"location":"lineages/","page":"Navigating lineages","title":"Navigating lineages","text":"To get the full descendants of a taxon (i.e. the children of its children, recursively), we can do:","category":"page"},{"location":"lineages/","page":"Navigating lineages","title":"Navigating lineages","text":"descendants(ncbi\"Diplectanidae\")","category":"page"},{"location":"lineages/","page":"Navigating lineages","title":"Navigating lineages","text":"We can also work upwards in the taxonomy, using the lineage function – it takes an optional stop_at argument, which is the farther up it will go:","category":"page"},{"location":"lineages/","page":"Navigating lineages","title":"Navigating lineages","text":"lineage(ncbi\"Lamellodiscus elegans\"; stop_at=ncbi\"Monogenea\")","category":"page"},{"location":"lineages/","page":"Navigating lineages","title":"Navigating lineages","text":"The rank function is useful to know where in the taxonomy you are:","category":"page"},{"location":"lineages/","page":"Navigating lineages","title":"Navigating lineages","text":"[t => rank(t) for t in lineage(ncbi\"Lamellodiscus elegans\"; stop_at=ncbi\"Monogenea\")]","category":"page"},{"location":"lineages/#Internal-functions","page":"Navigating lineages","title":"Internal functions","text":"","category":"section"},{"location":"lineages/","page":"Navigating lineages","title":"Navigating lineages","text":"NCBITaxonomy._descendants\nNCBITaxonomy._children\nNCBITaxonomy._taxa_from_id","category":"page"},{"location":"lineages/#NCBITaxonomy._descendants","page":"Navigating lineages","title":"NCBITaxonomy._descendants","text":"_descendants(id::T) where {T <: Int}\n\nRecursively get the descendants of a given node.\n\n\n\n\n\n","category":"function"},{"location":"lineages/#NCBITaxonomy._children","page":"Navigating lineages","title":"NCBITaxonomy._children","text":"_children(id::T) where {T <: Int}\n\nInternal function to retrieve the id of the children of a given node.\n\n\n\n\n\n","category":"function"},{"location":"lineages/#NCBITaxonomy._taxa_from_id","page":"Navigating lineages","title":"NCBITaxonomy._taxa_from_id","text":"_taxa_from_id(id::Vector{T}) where {T <: Int}\n\nGet a list of NCBITaxon from a vector of ids.\n\n\n\n\n\n","category":"function"},{"location":"portal/#Use-case:-the-portal-data","page":"Portal data use-case","title":"Use-case: the portal data","text":"","category":"section"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"In this example, we will use NCBITaxonomy to validate the names of the species used in the Portal teaching dataset:","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"Ernest, Morgan; Brown, James; Valone, Thomas; White, Ethan P. (2017): Portal Project Teaching Database. figshare. https://doi.org/10.6084/m9.figshare.1314459.v6","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"We will download a list of species from figshare, which is given as a JSON file:","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"using NCBITaxonomy\nusing DataFrames\nusing JSON\nusing StringDistances\n\nspecies_file = download(\"https://ndownloader.figshare.com/files/3299486\")\nspecies = JSON.parsefile(species_file)","category":"page"},{"location":"portal/#Cleaning-up-the-portal-names","page":"Portal data use-case","title":"Cleaning up the portal names","text":"","category":"section"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"There is are two things we want to do at this point: extract the species names from the file, and then validate that they are spelled correctly, or that they are the most recent taxonomic name according to NCBI.","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"We will store our results in a data frame:","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"cleanup = DataFrame(\n    code = String[],\n    portal = String[],\n    name = String[],\n    rank = Symbol[],\n    order = String[],\n    taxid = Int[]\n)","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"The next step is to loop throug the species, and figure out what to do with them:","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"for sp in species\n    portal_name = sp[\"species\"] == \"sp.\" ? sp[\"genus\"] : sp[\"genus\"]*\" \"*sp[\"species\"]\n    ncbi_tax = taxid(portal_name)\n    if isnothing(ncbi_tax)\n        ncbi_tax = taxid(portal_name; fuzzy=true)\n    end\n    ncbi_lin = lineage(ncbi_tax)\n    push!(cleanup,\n        (\n            sp[\"species_id\"], portal_name, ncbi_tax.name, rank(ncbi_tax),\n            first(filter(t -> isequal(:order)(rank(t)), lineage(ncbi_tax))).name,\n            ncbi_tax.id\n        )\n    )\nend\n\nfirst(cleanup, 5)","category":"page"},{"location":"portal/#Looking-at-species-with-a-name-discrepancy","page":"Portal data use-case","title":"Looking at species with a name discrepancy","text":"","category":"section"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"Finally, we can look at the codes for which there is a likely issue because the names do not match – this can be because of new names, improper use of vernacular, or spelling issues:","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"filter(r -> r.portal != r.name, cleanup)","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"Note that these results should always be manually curated. For example, two species have been assigned to groups that are obviously wrong:","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"filter(r -> r.order ∈ [\"Gentianales\",\"Hemiptera\"], cleanup)","category":"page"},{"location":"portal/#Fixing-the-mis-identified-species","page":"Portal data use-case","title":"Fixing the mis-identified species","text":"","category":"section"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"Well, the obvious choice here is manual cleaning. This is a good solution. Another thing that NCBITaxonomy offers is the ability to build a namefinder from a list of known NCBI taxa. This is good if we know that the names we expect to find are part of a reference list.","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"In this case, we know that the species are going to be vertebrates, so we can use the vertebratefinder function to restrict the search to these groups:","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"vertebratefinder(true)(\"Lizard\"; fuzzy=true)","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"However, this approach does not seem to work for the second group:","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"vertebratefinder(true)(\"Perognathus hispidus\"; fuzzy=true)","category":"page"},{"location":"portal/#The-mystery-of-the-hispid-pocket-mouse","page":"Portal data use-case","title":"The mystery of the hispid pocket mouse","text":"","category":"section"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"This one will not be solved by our approach, as it is an invalid name – Perognathus hispidus should actually be Chaetodipus hispidus. Here are the list of issues that result in this name not being identifiable easily. First, Chaetodipus is a valid name, for which Perognathus is not a synonym. So searching by genus is not going to help. Second, there are a whole lot of species that end with hispidus, and trying different string distances is not going to help. We can try:","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"vertebratefinder(true)(\"Perognathus hispidus\"; fuzzy=true, dist=DamerauLevenshtein)","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"This returns a valid taxon, but an incorrect one (the Olive-backed pocket mouse). There is no obvious way to solve this problem.","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"Or is it?","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"To solve the issue with Lizards, we had to move away from taxid, and use verterbatefinder to limit the scope of the search. It would save some time to use this for the entire portal dataset, so let's create a portalnamesolver function:","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"portalnamesolver = vertebratefinder(true)","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"It currently does not help with our example - but this is ok, as we cal use one of Julia's features to hard-code the solution: dispatching on values. Because portalnamesolver is a singleton function (due to the way namefinder works), we need to be explicit about which module we want to expand it from (the @__MODULE__ will get the appropriate value, which can be Main if you work from the REPL, the Weave sandbox if you are generatic a document, or your own module if you structure your analysis this wat):","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"Env = @__MODULE__\nfunction Env.portalnamesolver(::Type{Val{Symbol(\"Perognathus hispidus\")}})\n    return ncbi\"Chaetodipus hispidus\"\nend","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"This definition says \"every time we call the portalnamesolver with a Symbol containing this species name, return this species\". We can call it with:","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"portalnamesolver(Val{Symbol(\"Perognathus hispidus\")})","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"Note that this is not changing the behavior of our portalnamesolver, it is simply adding a method:","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"portalnamesolver(\"Lizards\"; fuzzy=true)","category":"page"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"At this point, we may want to update the very first loop, to use the portalnamesolver throughout.","category":"page"},{"location":"portal/#Wrapping-up","page":"Portal data use-case","title":"Wrapping-up","text":"","category":"section"},{"location":"portal/","page":"Portal data use-case","title":"Portal data use-case","text":"This vignette illustrates how to go through a list of names, and match them against the NCBI taxonomy. We have seen a number of functions from NCBITaxonomy, including fuzzy string searching,. using custom string distances, limiting the taxonomic scope of the search, and finally using value-based dispatch to fix the unfixable. The last step can be automated a lot by relying on Julia's existing code generation techniques, but this goes beyond the scope of this vignette.","category":"page"},{"location":"#NCBITaxonomy","page":"Index","title":"NCBITaxonomy","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"This package provides an interface to the NCBI Taxonomy. When installed, it will download the latest version of the taxonomy files from the NCBI ftp service. To update the version of the taxonomy you use, you need to build the package again. This package is developed as part of the activities of the Viral Emergence Research Initiative (VERENA) consortium, with financial support from the Institut de Valorisation des Données (IVADO) at Université de Montréal.","category":"page"},{"location":"#Overview-of-capacities","page":"Index","title":"Overview of capacities","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"retrieval of names from the taxonomy\nlisting of children and descendant taxa\nfuzzy matching of names","category":"page"},{"location":"#How-does-it-work?","page":"Index","title":"How does it work?","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Internally, the package relies on the files provided by NCBI to reconstruct the taxonomy – the README for what the files contain can be found here. Note that the files and their expected MD5 checksum are downloaded when the package is built, and the data are not extracted unless the checksum matches. The package will also check that the checksum on the server is different from the version on disk, to avoid downloading data for nothing.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Data are saved as arrow tables when the package is built, and these are loaded when the package is loaded with import or using, as DataFrames. These data frames are not exported, but they are used by the various function of the package. Note also that a number of fields are removed, and some tables are pre-merged - not at build time (so there is no information loss, and you are welcome to dig into the full data frame by reloading the arrow file), but at load time.","category":"page"},{"location":"","page":"Index","title":"Index","text":"The package will check that the local version of the taxonomy file is sufficiently recent (no older than about 30 days), and if this is not the case, will prompt the user to update to a more recent version.","category":"page"},{"location":"namefinding/#Finding-taxa","page":"Finding taxa","title":"Finding taxa","text":"","category":"section"},{"location":"namefinding/#The-taxid-function","page":"Finding taxa","title":"The taxid function","text":"","category":"section"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"taxid\nvernacular\nsynonyms","category":"page"},{"location":"namefinding/#NCBITaxonomy.taxid","page":"Finding taxa","title":"NCBITaxonomy.taxid","text":"taxid(name::T; fuzzy::Bool = false, verbose::Bool=false, dist=StringDistances.Levenshtein) where {T <: AbstractString}\n\nReturns the taxonomic ID of a taxon, given as a string. This function searches in the entire names table, which is unlikely to give a good performance when using fuzzy matching. We encourage the use of the namefinder function to build a custom version.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy.vernacular","page":"Finding taxa","title":"NCBITaxonomy.vernacular","text":"vernacular(t::NCBITaxon)\n\nThis function will return nothing if no vernacular name is known, and an array of names if found. It searches the \"common name\" and \"genbank common name\" category of the NCBI taxonomy name table.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy.synonyms","page":"Finding taxa","title":"NCBITaxonomy.synonyms","text":"synonyms(t::NCBITaxon)\n\nThis function will return nothing if no synonyms exist, and an array of names if they do. It returns all of the \n\n\n\n\n\n","category":"function"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"The taxid function will return a NCBITaxon object, which has two fields: name and id. We do not return the class attribute, because the package will always return the scientific name, as the examples below illustrate:","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"using NCBITaxonomy\ntaxid(\"Bos taurus\")","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"There is a convenience string macro to replace the taxid function:","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"ncbi\"Bos taurus\"","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"Note that because the names database contains vernacular and deprecated names, the scientific name will be returned, no matter what you search","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"taxid(\"cow\")","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"This may be a good point to note that we can use the vernacular function to get a list of NCBI-known vernacular names:","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"taxid(\"cow\") |> vernacular","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"You can pass an additional fuzzy=true keyword argument to the taxid function to perform fuzzy name matching using the Levenshtein distance:","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"taxid(\"Paradiplozon homion\", fuzzy=true)","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"Note that both fuzzy searching and non-standard naming come at a performance cost, so it is preferable to use the strict matching unless necessary. As a final note, you can specify any distance function from the StringDistances package, using the dist argument. This is true of taxid, and indeed of any function returned by a namefinder.","category":"page"},{"location":"namefinding/#Building-a-better-namefinder","page":"Finding taxa","title":"Building a better namefinder","text":"","category":"section"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"The namefinder function has one job: generating a function that works exactly like taxid, but only searches on a smaller subset of the data. In fact, taxid is a special case of namefinder, which simply searches the whole database.","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"namefinder\ndescendantsfinder","category":"page"},{"location":"namefinding/#NCBITaxonomy.namefinder","page":"Finding taxa","title":"NCBITaxonomy.namefinder","text":"namefinder(df::T) where {T <: DataFrame}\n\nGenerates a name-finding function that takes a string as an argument, and a boolean (fuzzy) as a keyword argument to switch from strict to fuzzy matching. The generated function will return a NCBITaxon for a given string. By default, the function taxid is working on the entire names table, which is going to be slow if there are many names to fuzzy match. The keyword argument verbose (default to false) indicates whether the distance to a fuzzy match must be printed. Finally, the dist keyword argument is one of the types implemented by StringDistances, and is used to switch the string distance measure used in fuzzy matching. The default is Levenshtein distance.\n\nUnder strict matching, if no match is found, the namefinder will return nothing. This can be used to switch to the fuzzy namefinder automatically. The fuzzy namefinder uses the findnearest function from StringDistances, which will always return something. The compare function from the same package may be used to see how similar the names are, and to decide whether to keep them.\n\nAltough the input dataframe is supposed to be a subset of the (unexported) names_table, all that is required is that it has the columns tax_id, name, and class. Make of that information what you wish...\n\n\n\n\n\nnamefinder(tax::Vector{NCBITaxon})\n\nReturns a namefinder function that is only limited to taxa from the list.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy.descendantsfinder","page":"Finding taxa","title":"NCBITaxonomy.descendantsfinder","text":"descendantsfinder(t::NCBITaxon)\n\nReturns a namefinder for all taxa below the one given as argument. This function calls descendants internally, so it might not be the optimal way when dealing with large groups.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"Here is an illustration of why using namefinders makes sense. Let's say we have to search for a potentially misspelled name:","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"@time taxid(\"Ebulavurus\"; fuzzy=true)","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"We can build a more efficient namefinder by selecting the nodes in the taxonomy that belong to the VRL division. Doing so requires to call namefinder on a DataFrame. Note that we are doing some merging here, which results in the data frame we use having more columns than the names data frame – but this does not matter, because the namefinder is not picky about having too much information.","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"using DataFrames, DataFramesMeta\nviralfinder = namefinder(\n  leftjoin(\n    @where(\n      select(NCBITaxonomy.nodes_table, [:tax_id, :division_code]),\n      :division_code .== Symbol(\"VRL\")\n    ),\n    NCBITaxonomy.names_table;\n    on = :tax_id\n  )\n)\n\n@time viralfinder(\"Bumbulu ebolavirus\"; fuzzy=true);","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"For searches in specific groups, the descendantsfinder is a convenient wrapper: it will return a namefinder limited to all taxa below its argument.","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"diplectanidfinder = descendantsfinder(taxid(\"Diplectanidae\"))\ndiplectanidfinder(\"Lamellodiscus\")","category":"page"},{"location":"namefinding/#Standard-namefinders","page":"Finding taxa","title":"Standard namefinders","text":"","category":"section"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"To save some time, there are namefinders pre-populated with the large-level taxonomic divisions.","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"bacteriafinder\nvirusfinder\nmammalfinder\nvertebratefinder\nplantfinder\ninvertebratefinder\nrodentfinder\nprimatefinder\nphagefinder\nenvironmentalsamplesfinder","category":"page"},{"location":"namefinding/#NCBITaxonomy.bacteriafinder","page":"Finding taxa","title":"NCBITaxonomy.bacteriafinder","text":"bacteriafinder()\n\nReturns a namefinder limited to the bacterial division of the NCBI taxonomy. See the documentation for namefinder and taxid for more information about arguments.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy.virusfinder","page":"Finding taxa","title":"NCBITaxonomy.virusfinder","text":"virusfinder()\n\nReturns a namefinder limited to the viral division of the NCBI taxonomy. See the documentation for namefinder and taxid for more information about arguments. Note that phage are covered by phagefinder.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy.mammalfinder","page":"Finding taxa","title":"NCBITaxonomy.mammalfinder","text":"mammalfinder(;inclusive::Bool=true)\n\nReturns a namefinder limited to the mammal division of the NCBI taxonomy. See the documentation for namefinder and taxid for more information about arguments.\n\nIf the keyword argument inclusive is set to false, this will not search for organisms assigned to a lower division, in this case rodents (covered by rodentfinder) and primates (covered by primatefinder). The default behavior is to include these groups.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy.vertebratefinder","page":"Finding taxa","title":"NCBITaxonomy.vertebratefinder","text":"vertebratefinder(;inclusive::Bool=true)\n\nReturns a namefinder limited to the vertebrate division of the NCBI taxonomy. See the documentation for namefinder and taxid for more information about arguments.\n\nIf the keyword argument inclusive is set to false, this will not search for organisms assigned to a lower division, in this case mammals (covered by mammalfinder). The default behavior is to include these groups, which also include the groups covered by mammalfinder itself.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy.plantfinder","page":"Finding taxa","title":"NCBITaxonomy.plantfinder","text":"plantfinder()\n\nReturns a namefinder limited to the \"plant and fungi\" division of the NCBI taxonomy. See the documentation for namefinder and taxid for more information about arguments.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy.invertebratefinder","page":"Finding taxa","title":"NCBITaxonomy.invertebratefinder","text":"invertebratefinder()\n\nReturns a namefinder limited to the invertebrate division of the NCBI taxonomy. See the documentation for namefinder and taxid for more information about arguments.\n\nNote that this is limited organisms not covered by plantfinder, bacteriafinder, and virusfinder.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy.rodentfinder","page":"Finding taxa","title":"NCBITaxonomy.rodentfinder","text":"rodentfinder()\n\nReturns a namefinder limited to the rodent division of the NCBI taxonomy. See the documentation for namefinder and taxid for more information about arguments.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy.primatefinder","page":"Finding taxa","title":"NCBITaxonomy.primatefinder","text":"primatefinder()\n\nReturns a namefinder limited to the primate division of the NCBI taxonomy. See the documentation for namefinder and taxid for more information about arguments.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy.phagefinder","page":"Finding taxa","title":"NCBITaxonomy.phagefinder","text":"phagefinder()\n\nReturns a namefinder limited to the phage division of the NCBI taxonomy. See the documentation for namefinder and taxid for more information about arguments.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy.environmentalsamplesfinder","page":"Finding taxa","title":"NCBITaxonomy.environmentalsamplesfinder","text":"environmentalsamplesfinder()\n\nReturns a namefinder limited to the environmental samples division of the NCBI taxonomy. See the documentation for namefinder and taxid for more information about arguments.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"All of these return a namefinder function – so for example, the viral example from above can be re-written simply as:","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"virusfinder()(\"Bumbulu ebolavirus\"; fuzzy=true)","category":"page"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"Note that we need to call the finder function to return the name finder. This may change in a future release.","category":"page"},{"location":"namefinding/#Internal-functions","page":"Finding taxa","title":"Internal functions","text":"","category":"section"},{"location":"namefinding/","page":"Finding taxa","title":"Finding taxa","text":"NCBITaxonomy._get_sciname_from_taxid\nNCBITaxonomy._df_from_taxlist","category":"page"},{"location":"namefinding/#NCBITaxonomy._get_sciname_from_taxid","page":"Finding taxa","title":"NCBITaxonomy._get_sciname_from_taxid","text":"_get_sciname_from_taxid(df::T, id::Int) where {T <: DataFrame}\n\nThis internal function will return a scientific name from a numerical id.\n\n\n\n\n\n","category":"function"},{"location":"namefinding/#NCBITaxonomy._df_from_taxlist","page":"Finding taxa","title":"NCBITaxonomy._df_from_taxlist","text":"_df_from_taxlist(tax::Vector{NCBITaxon})\n\nReturns a subset of the names dataframe based on a vector of taxa.\n\n\n\n\n\n","category":"function"}]
}
